{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"C SDK \uf0c1 Documentation for this SDK can be broken down into 4 distinct areas: Common Topics Basic Concepts MQTT Primer Error and Return codes Application Development Device Development Gateway Development Dependencies \uf0c1 Paho MQTT C Client OpenSSL development package Build \uf0c1 Build using GNU Makefile included in this repository # make Installation \uf0c1 Install the built libraries using make command # sudo make -C paho.mqtt.c install # sudo make install Uninstall \uf0c1 Uninstalling the libraries using make command # sudo make uninstall # sudo make -C paho.mqtt.c uninstall","title":"C SDK"},{"location":"#c-sdk","text":"Documentation for this SDK can be broken down into 4 distinct areas: Common Topics Basic Concepts MQTT Primer Error and Return codes Application Development Device Development Gateway Development","title":"C SDK"},{"location":"#dependencies","text":"Paho MQTT C Client OpenSSL development package","title":"Dependencies"},{"location":"#build","text":"Build using GNU Makefile included in this repository # make","title":"Build"},{"location":"#installation","text":"Install the built libraries using make command # sudo make -C paho.mqtt.c install # sudo make install","title":"Installation"},{"location":"#uninstall","text":"Uninstalling the libraries using make command # sudo make uninstall # sudo make -C paho.mqtt.c uninstall","title":"Uninstall"},{"location":"concepts/","text":"Basic Concepts \uf0c1 Thing Classes \uf0c1 The Internet is made up of \"things\", the most important concept to get to terms with when working with Watson IoT Platform is the idea of applications, devices, & gateways as three distinct classes of \"thing\" in your Internet of Things solution. Getting your physical device model right is essential to building a solution that will allow you to take advantage of all the advanced capabilities of Watson IoT. Devices \uf0c1 Devices are things that send data into the service (directly, or indirectly), and respond to commands directed at them. Send events Recieve commands Tip Devices in Watson IoT Platform are intended to mirror the physical deployment of hardware that will generate IoT data, regardless of whether it directly connects to the internet. Warning If you deploy 6 pieces of hardware each with seperate firmware, software, etc avoid the temptation to think that tracking these as individual devices has no value. Merging them into an \"abstract device\" representing all 6 when you register your physical device model in Watson IoT will make it more difficult to use advanced features of the platform as you explore Watson IoT Platform's advanced capabilities for device and data management. Tip Device can collect large amount of data. Depending on the use case, users will have to predict which data provides the most value. They can predict this based on impact of data collection, power consumption of the device, and data transmission speed and latency, how the data is consumed by back-end applications. Users will also have to decide on how to represent the event from devices. Sometimes it is difficult to decide what constitutes a device. For example, a commercial refrigeration units (used in departmental stores) may have multiple bins or compartments with temperature sensors in each of the compartments. In this case, each compartment can be modeled as a device with its own unique device ID or the whole unit could be one device with temperature data from each compartment. So, events could be modeled as different levels of abstraction. Example events: <b>Example 1:</b> Modeled as each temperature sensor as a device: {\"deviceId\":\"refUnit1_compartment1\",\"temp\":18} {\"deviceId\":\"refunit1_compartment2\",\"temp\":20} <b>Example 2:</b> Modeled as refrigeration unit as a device: {\"deviceId\":\"refunit1\",\"compartment1_temp\":18, \"compartment2_temp\":20} <b>Example 3:</b> Modeled as refrigeration unit as a device and temp data in an array: {\"deviceId\":\"refunit1\",\"compartments\":[{\"temp\":18},{\"temp\":20}]} Considering the size of event, and consumbility by back-end application, Example 3 is a better option to use compared with Example 1 and Example 2. Gateways \uf0c1 Gateways are things that send data into the service, respond to commands, are able to send data from other devices, and relay commands to other devices. Send events Recieve commands Send events on behalf of other devices Recieve commands sent to other devices Tip Use gateways when you are developing a solution where multiple physical devices exist that will not each directly communicate with Watson IoT Platform, but instead will report to a local device, which serves as a central contact point to the service. Each physical device should be registered to the platform as a device, even though it will not connect directly. The central point of contact is your gateway. The gateway should send multiple events on behalf of the local devices, rather than claiming ownership of the data by submitted the events as if the data came from the gateway itself. Applications \uf0c1 Applications are the most powerful class of thing in Watson IoT Platform. Send events on behalf of devices Send commands to devices Recieve commands sent to devices Work with the IBM Watson IoT Platform APIs Tip Applications are able to function as a gateway into the service, but should only be used as such when you view the gateway as an abstract entity in your solution rather than something physical to be managed on-site. If you assoicate the central point of contact with the platform as a specific piece of hardware it should be implemented as a gateway. Warning Applications capabilities vary wildly depending on the permissions granted to the application by the API key that it uses to connect. It is important to align the role granted to the API key used by the application to the capabilities of the application.","title":"Basic Concepts"},{"location":"concepts/#basic-concepts","text":"","title":"Basic Concepts"},{"location":"concepts/#thing-classes","text":"The Internet is made up of \"things\", the most important concept to get to terms with when working with Watson IoT Platform is the idea of applications, devices, & gateways as three distinct classes of \"thing\" in your Internet of Things solution. Getting your physical device model right is essential to building a solution that will allow you to take advantage of all the advanced capabilities of Watson IoT.","title":"Thing Classes"},{"location":"concepts/#devices","text":"Devices are things that send data into the service (directly, or indirectly), and respond to commands directed at them. Send events Recieve commands Tip Devices in Watson IoT Platform are intended to mirror the physical deployment of hardware that will generate IoT data, regardless of whether it directly connects to the internet. Warning If you deploy 6 pieces of hardware each with seperate firmware, software, etc avoid the temptation to think that tracking these as individual devices has no value. Merging them into an \"abstract device\" representing all 6 when you register your physical device model in Watson IoT will make it more difficult to use advanced features of the platform as you explore Watson IoT Platform's advanced capabilities for device and data management. Tip Device can collect large amount of data. Depending on the use case, users will have to predict which data provides the most value. They can predict this based on impact of data collection, power consumption of the device, and data transmission speed and latency, how the data is consumed by back-end applications. Users will also have to decide on how to represent the event from devices. Sometimes it is difficult to decide what constitutes a device. For example, a commercial refrigeration units (used in departmental stores) may have multiple bins or compartments with temperature sensors in each of the compartments. In this case, each compartment can be modeled as a device with its own unique device ID or the whole unit could be one device with temperature data from each compartment. So, events could be modeled as different levels of abstraction. Example events: <b>Example 1:</b> Modeled as each temperature sensor as a device: {\"deviceId\":\"refUnit1_compartment1\",\"temp\":18} {\"deviceId\":\"refunit1_compartment2\",\"temp\":20} <b>Example 2:</b> Modeled as refrigeration unit as a device: {\"deviceId\":\"refunit1\",\"compartment1_temp\":18, \"compartment2_temp\":20} <b>Example 3:</b> Modeled as refrigeration unit as a device and temp data in an array: {\"deviceId\":\"refunit1\",\"compartments\":[{\"temp\":18},{\"temp\":20}]} Considering the size of event, and consumbility by back-end application, Example 3 is a better option to use compared with Example 1 and Example 2.","title":"Devices"},{"location":"concepts/#gateways","text":"Gateways are things that send data into the service, respond to commands, are able to send data from other devices, and relay commands to other devices. Send events Recieve commands Send events on behalf of other devices Recieve commands sent to other devices Tip Use gateways when you are developing a solution where multiple physical devices exist that will not each directly communicate with Watson IoT Platform, but instead will report to a local device, which serves as a central contact point to the service. Each physical device should be registered to the platform as a device, even though it will not connect directly. The central point of contact is your gateway. The gateway should send multiple events on behalf of the local devices, rather than claiming ownership of the data by submitted the events as if the data came from the gateway itself.","title":"Gateways"},{"location":"concepts/#applications","text":"Applications are the most powerful class of thing in Watson IoT Platform. Send events on behalf of devices Send commands to devices Recieve commands sent to devices Work with the IBM Watson IoT Platform APIs Tip Applications are able to function as a gateway into the service, but should only be used as such when you view the gateway as an abstract entity in your solution rather than something physical to be managed on-site. If you assoicate the central point of contact with the platform as a specific piece of hardware it should be implemented as a gateway. Warning Applications capabilities vary wildly depending on the permissions granted to the application by the API key that it uses to connect. It is important to align the role granted to the API key used by the application to the capabilities of the application.","title":"Applications"},{"location":"errors/","text":"Return and Error Codes \uf0c1 The return and error codes in the SDK are common across all libraries (device, gateway, application, managed device, and managed gateway). Below is a summary of the returned return and error codes used in this SDK. Codes returned by C SDK \uf0c1 Retrun code 0 indicates a success reponse Return code 1 indicates a generic failure response Return codes 1001 to 1500 indicates failure response Codes returned by dependent Paho MQTT C library \uf0c1 Return code less than 0 are specific error codes returned by Paho MQTT C Client library. For details, refer to MQTTReasonCodes {target=\"_blank\"} in Paho Asynchronous MQTT C Client Library.","title":"Return and Error Codes"},{"location":"errors/#return-and-error-codes","text":"The return and error codes in the SDK are common across all libraries (device, gateway, application, managed device, and managed gateway). Below is a summary of the returned return and error codes used in this SDK.","title":"Return and Error Codes"},{"location":"errors/#codes-returned-by-c-sdk","text":"Retrun code 0 indicates a success reponse Return code 1 indicates a generic failure response Return codes 1001 to 1500 indicates failure response","title":"Codes returned by C SDK"},{"location":"errors/#codes-returned-by-dependent-paho-mqtt-c-library","text":"Return code less than 0 are specific error codes returned by Paho MQTT C Client library. For details, refer to MQTTReasonCodes {target=\"_blank\"} in Paho Asynchronous MQTT C Client Library.","title":"Codes returned by dependent Paho MQTT C library"},{"location":"mqtt/","text":"MQTT Primer \uf0c1 MQTT is the primary protocol that devices and applications use to communicate with IBM Watson IoT Platform. MQTT is a publish and subscribe messaging transport protocol that is designed for the efficient exchange of real-time data between sensor and mobile devices. MQTT support is available over TCP/IP and websockets, in your configuration file specify options.mqtt.transport=tcp or options.mqtt.transport=websockets Retained Messages \uf0c1 Watson IoT Platform provides limited support for the retained messages feature of MQTT messaging. If the retained message flag is set to true in an MQTT message that is sent from a device, gateway, or application to Watson IoT Platform, the message is handled as an unretained message. Quality of Service \uf0c1 The MQTT protocol provides three qualities of service for delivering messages between clients and servers: \"at most once\", \"at least once\", and \"exactly once\". While you can send events and commands by using any quality of service level, you must carefully consider what the right service level is for your needs. Quality of service level '2' is not always a better option than level '0'. At most once (QoS0) \uf0c1 The \"at most once\" quality of service level (QoS0) is the fastest mode of transfer and is sometimes called \"fire and forget\". The message is delivered at most once, or it might not be delivered at all. Delivery across the network is not acknowledged, and the message is not stored. The message might be lost if the client is disconnected, or if the server fails. The MQTT protocol does not require servers to forward publications at quality of service level '0' to a client. If the client is disconnected at the time the server receives the publication, the publication might be discarded, depending on the server implementation. Tip When sending real-time data on an interval, use quality of service level 0. If a single message goes missing, it does not really matter because another message that contains newer data will be sent shortly afterward. In this scenario, the extra cost of using a higher quality of service does not result in any tangible benefit. At least once (QoS1) \uf0c1 With quality of service level 1 (QoS1), the message is always delivered at least once. If a failure occurs before an acknowledgment is received by the sender, a message can be delivered multiple times. The message must be stored locally at the sender until the sender receives confirmation that the message was published by the receiver. The message is stored in case the message must be sent again. Exactly once (QoS2) \uf0c1 The \"exactly once\" quality of service level 2 (QoS2) is the safest, but slowest mode of transfer. The message is always delivered exactly once and must also be stored locally at the sender, until the sender receives confirmation that the message was published by the receiver. The message is stored in case the message must be sent again. With quality of service level 2, a more sophisticated handshaking and acknowledgment sequence is used than for level 1 to ensure that messages are not duplicated. Tip When sending commands, if you want confirmation that only the specified command will be actioned, and that it will be actioned once only, use the quality of service level 2. This is an example of when the additional overheads of level 2 can be advantageous over other levels. Subscription Buffers and Clean Session \uf0c1 Each subscription from either a device or application is allocated a buffer of 5000 messages. The buffer allows for any application or device to fall behind the live data it is processing, and to also build up a backlog of up to 5000 pending messages for each subscription it has made. When the buffer is full, the oldest messages are discarded when a new message is received. Use the MQTT clean session option to access the subscription buffer. When clean session is set to false, the subscriber receives messages from the buffer. When clean session is set to true, the buffer is reset. Warning The subscription buffer limit applies regardless of the quality of service setting that is used. It is possible that a message that is sent at level 1 or 2 might not be delivered to an application that is unable to keep up with the messages rate for the subscription that it has made. Message Payload Limitations \uf0c1 IBM Watson IoT Platform supports sending and receiving messages in any format. MQTT is data-agnostic so it's possible to send images, text in any encoding, encrypted data, or raw data in binary format. The maximum payload size on Watson IoT Platform is 131072 bytes. Warning Messages with a payload that is greater than the limit are rejected. The connecting client is also disconnected, and a message appears in the diagnostic logs, as outlined in the following device message example: Closed connection from x.x.x.x. The message size is too large for this endpoint. MQTT Keep Alive \uf0c1 The MQTT keep alive interval, which is measured in seconds, defines the maximum time that can pass without communication between the client and broker. The MQTT client must ensure that, in the absence of any other communication with the broker, a PINGREQ packet is sent. The keep alive interval allows both the client and the broker to detect that the network failed, resulting in a broken connection, without needing to wait for the TCP/IP timeout period to be reached. Warning If your application utilizes a shared subscription, the keep alive interval value can be set only to between 1 and 3600 seconds. If a value of 0 or a value that is greater than 3600 is requested, Watson IoT Platform sets the keep alive interval to 3600 seconds.","title":"MQTT Primer"},{"location":"mqtt/#mqtt-primer","text":"MQTT is the primary protocol that devices and applications use to communicate with IBM Watson IoT Platform. MQTT is a publish and subscribe messaging transport protocol that is designed for the efficient exchange of real-time data between sensor and mobile devices. MQTT support is available over TCP/IP and websockets, in your configuration file specify options.mqtt.transport=tcp or options.mqtt.transport=websockets","title":"MQTT Primer"},{"location":"mqtt/#retained-messages","text":"Watson IoT Platform provides limited support for the retained messages feature of MQTT messaging. If the retained message flag is set to true in an MQTT message that is sent from a device, gateway, or application to Watson IoT Platform, the message is handled as an unretained message.","title":"Retained Messages"},{"location":"mqtt/#quality-of-service","text":"The MQTT protocol provides three qualities of service for delivering messages between clients and servers: \"at most once\", \"at least once\", and \"exactly once\". While you can send events and commands by using any quality of service level, you must carefully consider what the right service level is for your needs. Quality of service level '2' is not always a better option than level '0'.","title":"Quality of Service"},{"location":"mqtt/#at-most-once-qos0","text":"The \"at most once\" quality of service level (QoS0) is the fastest mode of transfer and is sometimes called \"fire and forget\". The message is delivered at most once, or it might not be delivered at all. Delivery across the network is not acknowledged, and the message is not stored. The message might be lost if the client is disconnected, or if the server fails. The MQTT protocol does not require servers to forward publications at quality of service level '0' to a client. If the client is disconnected at the time the server receives the publication, the publication might be discarded, depending on the server implementation. Tip When sending real-time data on an interval, use quality of service level 0. If a single message goes missing, it does not really matter because another message that contains newer data will be sent shortly afterward. In this scenario, the extra cost of using a higher quality of service does not result in any tangible benefit.","title":"At most once (QoS0)"},{"location":"mqtt/#at-least-once-qos1","text":"With quality of service level 1 (QoS1), the message is always delivered at least once. If a failure occurs before an acknowledgment is received by the sender, a message can be delivered multiple times. The message must be stored locally at the sender until the sender receives confirmation that the message was published by the receiver. The message is stored in case the message must be sent again.","title":"At least once (QoS1)"},{"location":"mqtt/#exactly-once-qos2","text":"The \"exactly once\" quality of service level 2 (QoS2) is the safest, but slowest mode of transfer. The message is always delivered exactly once and must also be stored locally at the sender, until the sender receives confirmation that the message was published by the receiver. The message is stored in case the message must be sent again. With quality of service level 2, a more sophisticated handshaking and acknowledgment sequence is used than for level 1 to ensure that messages are not duplicated. Tip When sending commands, if you want confirmation that only the specified command will be actioned, and that it will be actioned once only, use the quality of service level 2. This is an example of when the additional overheads of level 2 can be advantageous over other levels.","title":"Exactly once (QoS2)"},{"location":"mqtt/#subscription-buffers-and-clean-session","text":"Each subscription from either a device or application is allocated a buffer of 5000 messages. The buffer allows for any application or device to fall behind the live data it is processing, and to also build up a backlog of up to 5000 pending messages for each subscription it has made. When the buffer is full, the oldest messages are discarded when a new message is received. Use the MQTT clean session option to access the subscription buffer. When clean session is set to false, the subscriber receives messages from the buffer. When clean session is set to true, the buffer is reset. Warning The subscription buffer limit applies regardless of the quality of service setting that is used. It is possible that a message that is sent at level 1 or 2 might not be delivered to an application that is unable to keep up with the messages rate for the subscription that it has made.","title":"Subscription Buffers and Clean Session"},{"location":"mqtt/#message-payload-limitations","text":"IBM Watson IoT Platform supports sending and receiving messages in any format. MQTT is data-agnostic so it's possible to send images, text in any encoding, encrypted data, or raw data in binary format. The maximum payload size on Watson IoT Platform is 131072 bytes. Warning Messages with a payload that is greater than the limit are rejected. The connecting client is also disconnected, and a message appears in the diagnostic logs, as outlined in the following device message example: Closed connection from x.x.x.x. The message size is too large for this endpoint.","title":"Message Payload Limitations"},{"location":"mqtt/#mqtt-keep-alive","text":"The MQTT keep alive interval, which is measured in seconds, defines the maximum time that can pass without communication between the client and broker. The MQTT client must ensure that, in the absence of any other communication with the broker, a PINGREQ packet is sent. The keep alive interval allows both the client and the broker to detect that the network failed, resulting in a broken connection, without needing to wait for the TCP/IP timeout period to be reached. Warning If your application utilizes a shared subscription, the keep alive interval value can be set only to between 1 and 3600 seconds. If a value of 0 or a value that is greater than 3600 is requested, Watson IoT Platform sets the keep alive interval to 3600 seconds.","title":"MQTT Keep Alive"},{"location":"application/","text":"Application SDK \uf0c1 The application SDK includes a shared library that exposes functions to build application client that runs on IoT applications. libwiotp-sdk-application-as.so Support APIs for creating a application client and managing connection to the Watson IoT Platform service: IoTPConfig_create() IoTPApplication_create() IoTPApplication_connect() Support APIs for working with events and commands: IoTPApplication_sendEvent() IoTPApplication_setEventCallback() IoTPApplication_setCommand() IoTPApplication_setCommandsHandler() IoTPApplication_subscribeToCommands() IoTPApplication_sendDeviceEvent() IoTPApplication_subscribeToDeviceCommands() Configuration \uf0c1 Application configuration is passed to the client via the IoTPConfig object when you create the client instance or handle IoTPApplication . See the configure applications section for full details of all available options to configure a client instance. The config handle IoTPConfig created using IoTPConfig_create() must be cleared using IoTPConfig_clear() to avoid handle leak. The application handle IoTPApplication created using IoTPApplication_create() must be destroyed using IoTPApplication_destory() to avoid handle leak. i Connectivity \uf0c1 IoTPApplication_connect() & IoTPApplication_disconnect() APIs are used to manage the MQTT connection to the Watson IoT Platform service that allows the application to handle commands and publish events. Publishing Events \uf0c1 Application can publish data collected by the application or on behalf of other devices. Events can be published with any of the three quality of service (QoS) levels that are defined by the MQTT protocol. By default, events are published with a QoS level of 0. Optionally you can send MQTT V5 properties. For details on MQTT V5 properties, refer to MQTTProperty . To send events, you can use IoTPApplication_sendEvent() API. This API takes upto 8 arguments: application Client handle typeId Device type Id deviceId Device Id event Name of the event data Data for this event msgFormat Format of the data for this event qos MQTT quality of service level to use ( 0 , 1 , or 2 ) props MQTT V5 properties You can set a callback to get send event response using IoTPApplication_setEventCallback() API. The callback returns success and failure responses. The success respose has different implications depending on the level of qos used to publish the event: qos 0: the client has asynchronously begun to send the event qos 1 and 2: the client has confirmation of delivery from the platform Publishing Commands \uf0c1 Application can publish command for a device or gateway. To publish commands, you can use IoTPApplication_sendCommand() API. This API takes upto 8 arguments: application Client handle typeId Device type Id deviceId Device Id command Name of the command data Data for this command msgFormat Format of the data for this command qos MQTT quality of service level to use ( 0 , 1 , or 2 ) props MQTT V5 properties Handling Events \uf0c1 An application client can susbcribe to device or gateway events using IoTPApplication_subscribeToEvents() API. To process specific commands, you need to register a event callback method, using IoTPApplication_setEventHandler() . The messages are returned as an instance of the Event class with the following attributes: type : Client type ID id : Client ID event : Identifies the event format : Format that the command was encoded in, for example json payload : Data for the payload payloadlen : Size of the payload buffer Handling Commands \uf0c1 An application client can susbcribe to a gateway or device command using IoTPApplication_subscribeToCommands() API. To process specific commands, you need to register a command callback method, using IoTPApplication_setCommandHandler() . The messages are returned as an instance of the Command class with the following attributes: type : Client type ID id : Client ID command : Identifies the command format : Format that the command was encoded in, for example json payload : Data for the payload payloadlen : Size of the payload buffer Sample \uf0c1 Sample configuration file \uf0c1 identity: orgId: org1id applicationId: testApplication auth: key: a-org1id-htan65Wisp token: hP!ax98sjcD Sample code \uf0c1 #include <iotp_application.h> /* Application command callback function. Application developers can customize this function for their use case. */ void applicationCommandCallback (char* type, char* id, char* commandName, char *format, void* payload, size_t payloadSize) { fprintf(stdout, \"Received application command. Type=%s ID=%s CommandName=%s Format=%s Len=%d\\n\", type?type:\"\", id?id:\"\", commandName?commandName:\"\", format?format:\"\", (int)payloadSize); /* Application developers - add your custom code to process application command and its payload */ } /* Application event callback function. */ void eventCallback(char *id, int rc, void *success void *failure) { fprintf(\"Event callback response for client: %s\\n\", id?id:\"\"); if ( rc == IOTPRC_SUCCESS ) { MQTTAsync_successData5 *response = success; if ( response ) { fprintf(\"Success response code:%d response_message:%s\\n\", response->code, response->message); } else { fprintf(\"Event is published.\\n\"); } } else { MQTTAsync_failureData5 *response = failure; if ( response ) { fprintf(\"Failure response code:%d response_message:%s\\n\", response->code, response->message); } else { fprintf(\"Failed to publish event.\\n\"); } } } int main(int argc, char *argv[]) { int rc = IOTPRC_SUCCESS; IoTPConfig *config = NULL; IoTPApplication *application = NULL; /*******************************************************/ /****** Create application client instance and connect ******/ /*******************************************************/ /* Create IoTPConfig object, use it to create IoTPApplication handle, and connect client */ rc = IoTPConfig_create(&config, \"configFile.yaml\"); if ( rc == IOTPRC_SUCCESS ) { rc = IoTPApplication_create(&application, config); if ( rc == IOTPRC_SUCCESS ) { rc = IoTPApplication_connect(application); } } if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to create application client: rc=%d reason=%s\\n\", rc, IOTPRC_toString(rc)); exit(1); } /******************************/ /****** Process commands ******/ /******************************/ /* Set application command callback for all commands and subscribe to all commands in any supported format */ rc = IoTPApplication_setCommandHandler(application, applicationCommandCallback, \"+\", \"+\", \"+\", \"+\"); if ( rc == IOTPRC_SUCCESS ) rc = IoTPApplication_subscribeToCommands(application, \"+\", \"+\", \"+\"); } if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to set command handler or subscribe to device commands. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /***********************************/ /****** Publish device events ******/ /***********************************/ /* Set event callback to process event response and send event */ rc = IoTPApplication_setEventCallback(application, eventCallback); if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to set event callback. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /* Set MQTT V5 properties */ MQTTProperties *properties = (MQTTProperties *)malloc(sizeof MQTTProperties); MQTTProperty property; property.identifier = MQTTPROPERTY_CODE_USER_PROPERTY; property.value.data.data = \"user defined property\"; property.value.data.len = (int)strlen(property.value.data.data); property.value.value.data = \"user defined property value\"; property.value.value.len = (int)strlen(property.value.value.data); rc = MQTTProperties_add(properties, &property); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to set MQTT V5 properties. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /* Set event data */ char *data = \"{\\\"d\\\" : {\\\"SensorID\\\": \\\"Test\\\", \\\"Reading\\\": 7 }}\"; rc = IoTPApplication_sendEvent(application, \"testDevType\", \"testDev\", \"status\", data, \"json\", QoS0, properties); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to publish device event. rc=%d\\n\", rc); } else { /* wait for sometime to publish event */ sleep(5); } /*********************/ /****** Cleanup ******/ /*********************/ /* Disconnect, and cleaup */ rc = IoTPApplication_disconnect(application); if ( rc == IOTPRC_SUCCESS ) { /* Destroy client */ rc = IoTPApplication_destroy(application); if ( rc == IOTPRC_SUCCESS ) { /* Clear configuration */ rc = IoTPConfig_clear(config); } } if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to disconnect or clean handles. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } return rc; } Application SDK Reference \uf0c1 For application configuration APIs, refer to Configuration Refernce Documentation For application client APIs, refer to Application Client Refernce Documentation For Return and error codes by C Client SDK, refer to Return Code Refernce Documentation","title":"Application SDK"},{"location":"application/#application-sdk","text":"The application SDK includes a shared library that exposes functions to build application client that runs on IoT applications. libwiotp-sdk-application-as.so Support APIs for creating a application client and managing connection to the Watson IoT Platform service: IoTPConfig_create() IoTPApplication_create() IoTPApplication_connect() Support APIs for working with events and commands: IoTPApplication_sendEvent() IoTPApplication_setEventCallback() IoTPApplication_setCommand() IoTPApplication_setCommandsHandler() IoTPApplication_subscribeToCommands() IoTPApplication_sendDeviceEvent() IoTPApplication_subscribeToDeviceCommands()","title":"Application SDK"},{"location":"application/#configuration","text":"Application configuration is passed to the client via the IoTPConfig object when you create the client instance or handle IoTPApplication . See the configure applications section for full details of all available options to configure a client instance. The config handle IoTPConfig created using IoTPConfig_create() must be cleared using IoTPConfig_clear() to avoid handle leak. The application handle IoTPApplication created using IoTPApplication_create() must be destroyed using IoTPApplication_destory() to avoid handle leak. i","title":"Configuration"},{"location":"application/#connectivity","text":"IoTPApplication_connect() & IoTPApplication_disconnect() APIs are used to manage the MQTT connection to the Watson IoT Platform service that allows the application to handle commands and publish events.","title":"Connectivity"},{"location":"application/#publishing-events","text":"Application can publish data collected by the application or on behalf of other devices. Events can be published with any of the three quality of service (QoS) levels that are defined by the MQTT protocol. By default, events are published with a QoS level of 0. Optionally you can send MQTT V5 properties. For details on MQTT V5 properties, refer to MQTTProperty . To send events, you can use IoTPApplication_sendEvent() API. This API takes upto 8 arguments: application Client handle typeId Device type Id deviceId Device Id event Name of the event data Data for this event msgFormat Format of the data for this event qos MQTT quality of service level to use ( 0 , 1 , or 2 ) props MQTT V5 properties You can set a callback to get send event response using IoTPApplication_setEventCallback() API. The callback returns success and failure responses. The success respose has different implications depending on the level of qos used to publish the event: qos 0: the client has asynchronously begun to send the event qos 1 and 2: the client has confirmation of delivery from the platform","title":"Publishing Events"},{"location":"application/#publishing-commands","text":"Application can publish command for a device or gateway. To publish commands, you can use IoTPApplication_sendCommand() API. This API takes upto 8 arguments: application Client handle typeId Device type Id deviceId Device Id command Name of the command data Data for this command msgFormat Format of the data for this command qos MQTT quality of service level to use ( 0 , 1 , or 2 ) props MQTT V5 properties","title":"Publishing Commands"},{"location":"application/#handling-events","text":"An application client can susbcribe to device or gateway events using IoTPApplication_subscribeToEvents() API. To process specific commands, you need to register a event callback method, using IoTPApplication_setEventHandler() . The messages are returned as an instance of the Event class with the following attributes: type : Client type ID id : Client ID event : Identifies the event format : Format that the command was encoded in, for example json payload : Data for the payload payloadlen : Size of the payload buffer","title":"Handling Events"},{"location":"application/#handling-commands","text":"An application client can susbcribe to a gateway or device command using IoTPApplication_subscribeToCommands() API. To process specific commands, you need to register a command callback method, using IoTPApplication_setCommandHandler() . The messages are returned as an instance of the Command class with the following attributes: type : Client type ID id : Client ID command : Identifies the command format : Format that the command was encoded in, for example json payload : Data for the payload payloadlen : Size of the payload buffer","title":"Handling Commands"},{"location":"application/#sample","text":"","title":"Sample"},{"location":"application/#sample-configuration-file","text":"identity: orgId: org1id applicationId: testApplication auth: key: a-org1id-htan65Wisp token: hP!ax98sjcD","title":"Sample configuration file"},{"location":"application/#sample-code","text":"#include <iotp_application.h> /* Application command callback function. Application developers can customize this function for their use case. */ void applicationCommandCallback (char* type, char* id, char* commandName, char *format, void* payload, size_t payloadSize) { fprintf(stdout, \"Received application command. Type=%s ID=%s CommandName=%s Format=%s Len=%d\\n\", type?type:\"\", id?id:\"\", commandName?commandName:\"\", format?format:\"\", (int)payloadSize); /* Application developers - add your custom code to process application command and its payload */ } /* Application event callback function. */ void eventCallback(char *id, int rc, void *success void *failure) { fprintf(\"Event callback response for client: %s\\n\", id?id:\"\"); if ( rc == IOTPRC_SUCCESS ) { MQTTAsync_successData5 *response = success; if ( response ) { fprintf(\"Success response code:%d response_message:%s\\n\", response->code, response->message); } else { fprintf(\"Event is published.\\n\"); } } else { MQTTAsync_failureData5 *response = failure; if ( response ) { fprintf(\"Failure response code:%d response_message:%s\\n\", response->code, response->message); } else { fprintf(\"Failed to publish event.\\n\"); } } } int main(int argc, char *argv[]) { int rc = IOTPRC_SUCCESS; IoTPConfig *config = NULL; IoTPApplication *application = NULL; /*******************************************************/ /****** Create application client instance and connect ******/ /*******************************************************/ /* Create IoTPConfig object, use it to create IoTPApplication handle, and connect client */ rc = IoTPConfig_create(&config, \"configFile.yaml\"); if ( rc == IOTPRC_SUCCESS ) { rc = IoTPApplication_create(&application, config); if ( rc == IOTPRC_SUCCESS ) { rc = IoTPApplication_connect(application); } } if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to create application client: rc=%d reason=%s\\n\", rc, IOTPRC_toString(rc)); exit(1); } /******************************/ /****** Process commands ******/ /******************************/ /* Set application command callback for all commands and subscribe to all commands in any supported format */ rc = IoTPApplication_setCommandHandler(application, applicationCommandCallback, \"+\", \"+\", \"+\", \"+\"); if ( rc == IOTPRC_SUCCESS ) rc = IoTPApplication_subscribeToCommands(application, \"+\", \"+\", \"+\"); } if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to set command handler or subscribe to device commands. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /***********************************/ /****** Publish device events ******/ /***********************************/ /* Set event callback to process event response and send event */ rc = IoTPApplication_setEventCallback(application, eventCallback); if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to set event callback. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /* Set MQTT V5 properties */ MQTTProperties *properties = (MQTTProperties *)malloc(sizeof MQTTProperties); MQTTProperty property; property.identifier = MQTTPROPERTY_CODE_USER_PROPERTY; property.value.data.data = \"user defined property\"; property.value.data.len = (int)strlen(property.value.data.data); property.value.value.data = \"user defined property value\"; property.value.value.len = (int)strlen(property.value.value.data); rc = MQTTProperties_add(properties, &property); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to set MQTT V5 properties. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /* Set event data */ char *data = \"{\\\"d\\\" : {\\\"SensorID\\\": \\\"Test\\\", \\\"Reading\\\": 7 }}\"; rc = IoTPApplication_sendEvent(application, \"testDevType\", \"testDev\", \"status\", data, \"json\", QoS0, properties); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to publish device event. rc=%d\\n\", rc); } else { /* wait for sometime to publish event */ sleep(5); } /*********************/ /****** Cleanup ******/ /*********************/ /* Disconnect, and cleaup */ rc = IoTPApplication_disconnect(application); if ( rc == IOTPRC_SUCCESS ) { /* Destroy client */ rc = IoTPApplication_destroy(application); if ( rc == IOTPRC_SUCCESS ) { /* Clear configuration */ rc = IoTPConfig_clear(config); } } if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to disconnect or clean handles. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } return rc; }","title":"Sample code"},{"location":"application/#application-sdk-reference","text":"For application configuration APIs, refer to Configuration Refernce Documentation For application client APIs, refer to Application Client Refernce Documentation For Return and error codes by C Client SDK, refer to Return Code Refernce Documentation","title":"Application SDK Reference"},{"location":"application/config/","text":"Application Configuration \uf0c1 Application configuration can be broken down into required and optional configuration: Required Configuration \uf0c1 identity.orgId Your organization ID. identity.typeId The type of the application device. Think of the application type is analagous to a model number. identity.deviceId A unique ID to identify a application device. Think of the application id as analagous to a serial number. auth.token An authentication token to securely connect your application device to Watson IoT Platform. Optional Configuration \uf0c1 options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to 8883 . options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when creating a application client handle IoTPApplication expects to be passed as IoTPConfig object. The application client SDK prrovides three APIs to create or update IoTPConfig object: IoTPConfig_create to read config parameters from an YAML file. IoTPConfig_readEnvironment to read config parameters from environment valiarbles. IoTPConfig_setProperty to set a config parameter by passing parameter name and value. YAML File Support \uf0c1 The client library allows one to easily pass in application device configuration using a file. #include <iotp_application.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPApplication *application = NULL; IoTPConfig_create(&config, \"application.yaml\"); IoTPApplication_create(&application, config); Minimal Required Configuration File \uf0c1 identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 Complete Configuration File \uf0c1 This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem Environment Variable Support \uf0c1 The client library allows one to easily pass in device configuration from environment variables. #include <iotp_application.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPApplication *application = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_readEnvironment(config); IoTPApplication_create(&application, config); Minimal Required Environment Variables \uf0c1 WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN Optional Additional Environment Variables \uf0c1 WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE Use API to set a specific config parameter \uf0c1 The client library allows one to set config parameter using IoTPConfig_setProperty API. #include <iotp_application.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPApplication *application = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_setProperty(config, \"identity.orgId\", \"a52xin\"); IoTPConfig_setProperty(config, \"identity.typeId\", \"rasberry-pi\"); IoTPConfig_setProperty(config, \"identity.deviceId\", \"00ef08c05\"); IoTPConfig_setProperty(config, \"token.deviceId\", \"Ab$76s)asj8_s5\"); IoTPApplication_create(&application, config);","title":"Configuration"},{"location":"application/config/#application-configuration","text":"Application configuration can be broken down into required and optional configuration:","title":"Application Configuration"},{"location":"application/config/#required-configuration","text":"identity.orgId Your organization ID. identity.typeId The type of the application device. Think of the application type is analagous to a model number. identity.deviceId A unique ID to identify a application device. Think of the application id as analagous to a serial number. auth.token An authentication token to securely connect your application device to Watson IoT Platform.","title":"Required Configuration"},{"location":"application/config/#optional-configuration","text":"options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to 8883 . options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when creating a application client handle IoTPApplication expects to be passed as IoTPConfig object. The application client SDK prrovides three APIs to create or update IoTPConfig object: IoTPConfig_create to read config parameters from an YAML file. IoTPConfig_readEnvironment to read config parameters from environment valiarbles. IoTPConfig_setProperty to set a config parameter by passing parameter name and value.","title":"Optional Configuration"},{"location":"application/config/#yaml-file-support","text":"The client library allows one to easily pass in application device configuration using a file. #include <iotp_application.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPApplication *application = NULL; IoTPConfig_create(&config, \"application.yaml\"); IoTPApplication_create(&application, config);","title":"YAML File Support"},{"location":"application/config/#minimal-required-configuration-file","text":"identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5","title":"Minimal Required Configuration File"},{"location":"application/config/#complete-configuration-file","text":"This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem","title":"Complete Configuration File"},{"location":"application/config/#environment-variable-support","text":"The client library allows one to easily pass in device configuration from environment variables. #include <iotp_application.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPApplication *application = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_readEnvironment(config); IoTPApplication_create(&application, config);","title":"Environment Variable Support"},{"location":"application/config/#minimal-required-environment-variables","text":"WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN","title":"Minimal Required Environment Variables"},{"location":"application/config/#optional-additional-environment-variables","text":"WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE","title":"Optional Additional Environment Variables"},{"location":"application/config/#use-api-to-set-a-specific-config-parameter","text":"The client library allows one to set config parameter using IoTPConfig_setProperty API. #include <iotp_application.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPApplication *application = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_setProperty(config, \"identity.orgId\", \"a52xin\"); IoTPConfig_setProperty(config, \"identity.typeId\", \"rasberry-pi\"); IoTPConfig_setProperty(config, \"identity.deviceId\", \"00ef08c05\"); IoTPConfig_setProperty(config, \"token.deviceId\", \"Ab$76s)asj8_s5\"); IoTPApplication_create(&application, config);","title":"Use API to set a specific config parameter"},{"location":"device/","text":"Device SDK \uf0c1 The device SDK includes a shared library that exposes functions to build device client that runs on IoT devices. libwiotp-sdk-device-as.so Support APIs for creating a device client and managing connection to the Watson IoT Platform service: IoTPConfig_create() IoTPDevice_create() IoTPDevice_connect() Support APIs for working with events and commands: IoTPDevice_sendEvent() IoTPDevice_setEventCallback() IoTPDevice_setCommandsHandler() IoTPDevice_subscribeToCommands() Configuration \uf0c1 Device configuration is passed to the client via the IoTPConfig object when you create the client instance or handle IoTPDevice . See the configure devices section for full details of all available options to configure a client instance. The config handle IoTPConfig created using IoTPConfig_create() must be cleared using IoTPConfig_clear() to avoid handle leak. The device handle IoTPDevice created using IoTPDevice_create() must be destroyed using IoTPDevice_destory() to avoid handle leak. Connectivity \uf0c1 IoTPDevice_connect() & IoTPDevice_disconnect() APIs are used to manage the MQTT connection to the Watson IoT Platform service that allows the device to handle commands and publish events. Tip Though there are no restrictions on how many device clients, a device application can create, it is a good practice to not to create many client handles and connect to the Watson IoT platform service, to limit the number of connections to the Watson IoT Platforrm service, and reduce load on the Watson IoT Platform service. Publishing Events \uf0c1 Device can provide various types of information, for example data collected by the device (telemetry data), current status of the device etc. Events are the mechanism by which devices publish data to the Watson IoT Platform service. The device controls the content of the event and assigns a name for each event that it sends. When an event is received by Watson IoT Platform service, the credentials of the received event identify the sending device, which means that a device cannot impersonate another device. Events can be published with any of the three quality of service (QoS) levels that are defined by the MQTT protocol. By default, events are published with a QoS level of 0. Optionally you can send MQTT V5 properties. For details on MQTT V5 properties, refer to MQTTProperty . To send events, you can use IoTPDevice_sendEvent() API. This API takes upto 6 arguments: device Client handle event Name of this event msgFormat Format of the data for this event data Data for this event qos MQTT quality of service level to use ( 0 , 1 , or 2 ) props MQTT V5 properties You can set a callback to get send event response using IoTPDevice_setEventCallback() API. The callback returns success and failure responses. The success respose has different implications depending on the level of qos used to publish the event: qos 0: the client has asynchronously begun to send the event qos 1 and 2: the client has confirmation of delivery from the platform Handling Commands \uf0c1 A device client can susbcribe to a command using IoTPDevice_subscribeToCommands() API. To process specific commands, you need to register a command callback method, using IoTPDevice_setCommandHandler() . The messages are returned as an instance of the Command class with the following attributes: type : Client type ID id : Client ID command : Identifies the command format : Format that the command was encoded in, for example json payload : Data for the payload payloadlen : Size of the payload buffer Sample \uf0c1 Sample configuration file \uf0c1 identity: orgId: org1id typeId: testDeviceType deviceId: testDevice auth: token: testPassword Sample code \uf0c1 #include <iotp_device.h> /* Device command callback function. Device developers can customize this function for their use case. */ void deviceCommandCallback (char* type, char* id, char* commandName, char *format, void* payload, size_t payloadSize) { fprintf(stdout, \"Received device command. Type=%s ID=%s CommandName=%s Format=%s Len=%d\\n\", type?type:\"\", id?id:\"\", commandName?commandName:\"\", format?format:\"\", (int)payloadSize); /* Device developers - add your custom code to process device command and its payload */ } /* Device event callback function. */ void eventCallback(char *id, int rc, void *success void *failure) { fprintf(\"Event callback response for client: %s\\n\", id?id:\"\"); if ( rc == IOTPRC_SUCCESS ) { MQTTAsync_successData5 *response = success; if ( response ) { fprintf(\"Success response code:%d response_message:%s\\n\", response->code, response->message); } else { fprintf(\"Event is published.\\n\"); } } else { MQTTAsync_failureData5 *response = failure; if ( response ) { fprintf(\"Failure response code:%d response_message:%s\\n\", response->code, response->message); } else { fprintf(\"Failed to publish event.\\n\"); } } } int main(int argc, char *argv[]) { int rc = IOTPRC_SUCCESS; IoTPConfig *config = NULL; IoTPDevice *device = NULL; /*******************************************************/ /****** Create device client instance and connect ******/ /*******************************************************/ /* Create IoTPConfig object, use it to create IoTPDevice handle, and connect client */ rc = IoTPConfig_create(&config, \"configFile.yaml\"); if ( rc == IOTPRC_SUCCESS ) { rc = IoTPDevice_create(&device, config); if ( rc == IOTPRC_SUCCESS ) { rc = IoTPDevice_connect(device); } } if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to create device client: rc=%d reason=%s\\n\", rc, IOTPRC_toString(rc)); exit(1); } /******************************/ /****** Process commands ******/ /******************************/ /* Set device command callback for all commands and subscribe to all commands in any supported format */ rc = IoTPDevice_setCommandsHandler(device, deviceCommandCallback); if ( rc == IOTPRC_SUCCESS ) rc = IoTPDevice_subscribeToCommands(device, \"+\", \"+\"); } if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to set command handler or subscribe to commands. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /****************************/ /****** Publish events ******/ /****************************/ /* Set event callback to process event response and send event */ rc = IoTPDevice_setEventCallback(device, eventCallback); if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to set event callback. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /* Set MQTT V5 properties */ MQTTProperties *properties = (MQTTProperties *)malloc(sizeof MQTTProperties); MQTTProperty property; property.identifier = MQTTPROPERTY_CODE_USER_PROPERTY; property.value.data.data = \"user defined property\"; property.value.data.len = (int)strlen(property.value.data.data); property.value.value.data = \"user defined property value\"; property.value.value.len = (int)strlen(property.value.value.data); rc = MQTTProperties_add(properties, &property); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to set MQTT V5 properties. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /* Set event data */ char *data = \"{\\\"d\\\" : {\\\"SensorID\\\": \\\"Test\\\", \\\"Reading\\\": 7 }}\"; rc = IoTPDevice_sendEvent(device,\"status\", data, \"json\", QoS0, properties); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to publish event. rc=%d\\n\", rc); } else { /* wait for sometime to publish data */ sleep(5); } /*********************/ /****** Cleanup ******/ /*********************/ /* Disconnect, and cleaup */ rc = IoTPDevice_disconnect(device); if ( rc == IOTPRC_SUCCESS ) { /* Destroy client */ rc = IoTPDevice_destroy(device); if ( rc == IOTPRC_SUCCESS ) { /* Clear configuration */ rc = IoTPConfig_clear(config); } } if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to disconnect or clean handles. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } return rc; } Device SDK Reference \uf0c1 For device configuration APIs, refer to Configuration Refernce Documentation For device client APIs, refer to Device Client Refernce Documentation For Return and error codes by C Client SDK, refer to Return Code Refernce Documentation","title":"Device SDK"},{"location":"device/#device-sdk","text":"The device SDK includes a shared library that exposes functions to build device client that runs on IoT devices. libwiotp-sdk-device-as.so Support APIs for creating a device client and managing connection to the Watson IoT Platform service: IoTPConfig_create() IoTPDevice_create() IoTPDevice_connect() Support APIs for working with events and commands: IoTPDevice_sendEvent() IoTPDevice_setEventCallback() IoTPDevice_setCommandsHandler() IoTPDevice_subscribeToCommands()","title":"Device SDK"},{"location":"device/#configuration","text":"Device configuration is passed to the client via the IoTPConfig object when you create the client instance or handle IoTPDevice . See the configure devices section for full details of all available options to configure a client instance. The config handle IoTPConfig created using IoTPConfig_create() must be cleared using IoTPConfig_clear() to avoid handle leak. The device handle IoTPDevice created using IoTPDevice_create() must be destroyed using IoTPDevice_destory() to avoid handle leak.","title":"Configuration"},{"location":"device/#connectivity","text":"IoTPDevice_connect() & IoTPDevice_disconnect() APIs are used to manage the MQTT connection to the Watson IoT Platform service that allows the device to handle commands and publish events. Tip Though there are no restrictions on how many device clients, a device application can create, it is a good practice to not to create many client handles and connect to the Watson IoT platform service, to limit the number of connections to the Watson IoT Platforrm service, and reduce load on the Watson IoT Platform service.","title":"Connectivity"},{"location":"device/#publishing-events","text":"Device can provide various types of information, for example data collected by the device (telemetry data), current status of the device etc. Events are the mechanism by which devices publish data to the Watson IoT Platform service. The device controls the content of the event and assigns a name for each event that it sends. When an event is received by Watson IoT Platform service, the credentials of the received event identify the sending device, which means that a device cannot impersonate another device. Events can be published with any of the three quality of service (QoS) levels that are defined by the MQTT protocol. By default, events are published with a QoS level of 0. Optionally you can send MQTT V5 properties. For details on MQTT V5 properties, refer to MQTTProperty . To send events, you can use IoTPDevice_sendEvent() API. This API takes upto 6 arguments: device Client handle event Name of this event msgFormat Format of the data for this event data Data for this event qos MQTT quality of service level to use ( 0 , 1 , or 2 ) props MQTT V5 properties You can set a callback to get send event response using IoTPDevice_setEventCallback() API. The callback returns success and failure responses. The success respose has different implications depending on the level of qos used to publish the event: qos 0: the client has asynchronously begun to send the event qos 1 and 2: the client has confirmation of delivery from the platform","title":"Publishing Events"},{"location":"device/#handling-commands","text":"A device client can susbcribe to a command using IoTPDevice_subscribeToCommands() API. To process specific commands, you need to register a command callback method, using IoTPDevice_setCommandHandler() . The messages are returned as an instance of the Command class with the following attributes: type : Client type ID id : Client ID command : Identifies the command format : Format that the command was encoded in, for example json payload : Data for the payload payloadlen : Size of the payload buffer","title":"Handling Commands"},{"location":"device/#sample","text":"","title":"Sample"},{"location":"device/#sample-configuration-file","text":"identity: orgId: org1id typeId: testDeviceType deviceId: testDevice auth: token: testPassword","title":"Sample configuration file"},{"location":"device/#sample-code","text":"#include <iotp_device.h> /* Device command callback function. Device developers can customize this function for their use case. */ void deviceCommandCallback (char* type, char* id, char* commandName, char *format, void* payload, size_t payloadSize) { fprintf(stdout, \"Received device command. Type=%s ID=%s CommandName=%s Format=%s Len=%d\\n\", type?type:\"\", id?id:\"\", commandName?commandName:\"\", format?format:\"\", (int)payloadSize); /* Device developers - add your custom code to process device command and its payload */ } /* Device event callback function. */ void eventCallback(char *id, int rc, void *success void *failure) { fprintf(\"Event callback response for client: %s\\n\", id?id:\"\"); if ( rc == IOTPRC_SUCCESS ) { MQTTAsync_successData5 *response = success; if ( response ) { fprintf(\"Success response code:%d response_message:%s\\n\", response->code, response->message); } else { fprintf(\"Event is published.\\n\"); } } else { MQTTAsync_failureData5 *response = failure; if ( response ) { fprintf(\"Failure response code:%d response_message:%s\\n\", response->code, response->message); } else { fprintf(\"Failed to publish event.\\n\"); } } } int main(int argc, char *argv[]) { int rc = IOTPRC_SUCCESS; IoTPConfig *config = NULL; IoTPDevice *device = NULL; /*******************************************************/ /****** Create device client instance and connect ******/ /*******************************************************/ /* Create IoTPConfig object, use it to create IoTPDevice handle, and connect client */ rc = IoTPConfig_create(&config, \"configFile.yaml\"); if ( rc == IOTPRC_SUCCESS ) { rc = IoTPDevice_create(&device, config); if ( rc == IOTPRC_SUCCESS ) { rc = IoTPDevice_connect(device); } } if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to create device client: rc=%d reason=%s\\n\", rc, IOTPRC_toString(rc)); exit(1); } /******************************/ /****** Process commands ******/ /******************************/ /* Set device command callback for all commands and subscribe to all commands in any supported format */ rc = IoTPDevice_setCommandsHandler(device, deviceCommandCallback); if ( rc == IOTPRC_SUCCESS ) rc = IoTPDevice_subscribeToCommands(device, \"+\", \"+\"); } if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to set command handler or subscribe to commands. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /****************************/ /****** Publish events ******/ /****************************/ /* Set event callback to process event response and send event */ rc = IoTPDevice_setEventCallback(device, eventCallback); if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to set event callback. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /* Set MQTT V5 properties */ MQTTProperties *properties = (MQTTProperties *)malloc(sizeof MQTTProperties); MQTTProperty property; property.identifier = MQTTPROPERTY_CODE_USER_PROPERTY; property.value.data.data = \"user defined property\"; property.value.data.len = (int)strlen(property.value.data.data); property.value.value.data = \"user defined property value\"; property.value.value.len = (int)strlen(property.value.value.data); rc = MQTTProperties_add(properties, &property); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to set MQTT V5 properties. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /* Set event data */ char *data = \"{\\\"d\\\" : {\\\"SensorID\\\": \\\"Test\\\", \\\"Reading\\\": 7 }}\"; rc = IoTPDevice_sendEvent(device,\"status\", data, \"json\", QoS0, properties); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to publish event. rc=%d\\n\", rc); } else { /* wait for sometime to publish data */ sleep(5); } /*********************/ /****** Cleanup ******/ /*********************/ /* Disconnect, and cleaup */ rc = IoTPDevice_disconnect(device); if ( rc == IOTPRC_SUCCESS ) { /* Destroy client */ rc = IoTPDevice_destroy(device); if ( rc == IOTPRC_SUCCESS ) { /* Clear configuration */ rc = IoTPConfig_clear(config); } } if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to disconnect or clean handles. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } return rc; }","title":"Sample code"},{"location":"device/#device-sdk-reference","text":"For device configuration APIs, refer to Configuration Refernce Documentation For device client APIs, refer to Device Client Refernce Documentation For Return and error codes by C Client SDK, refer to Return Code Refernce Documentation","title":"Device SDK Reference"},{"location":"device/config/","text":"Device Configuration \uf0c1 Device configuration can be broken down into required and optional configuration: Required Configuration \uf0c1 identity.orgId Your organization ID. identity.typeId The type of the device. Think of the device type is analagous to a model number. identity.deviceId A unique ID to identify a device. Think of the device id as analagous to a serial number. auth.token An authentication token to securely connect your device to Watson IoT Platform. Optional Configuration \uf0c1 options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to 8883 . options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when creating a device client handle IoTPDevice expects to be passed as IoTPConfig object. The device client SDK prrovides three APIs to create or update IoTPConfig object: IoTPConfig_create to read config parameters from an YAML file. IoTPConfig_readEnvironment to read config parameters from environment valiarbles. IoTPConfig_setProperty to set a config parameter by passing parameter name and value. YAML File Support \uf0c1 The client library allows one to easily pass in device configuration using a file. #include <iotp_device.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPDevice *device = NULL; IoTPConfig_create(&config, \"device.yaml\"); IoTPDevice_create(&device, config); Minimal Required Configuration File \uf0c1 identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 Complete Configuration File \uf0c1 This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem Environment Variable Support \uf0c1 The client library allows one to easily pass in device configuration from environment variables. #include <iotp_device.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPDevice *device = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_readEnvironment(config); IoTPDevice_create(&device, config); Minimal Required Environment Variables \uf0c1 WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN Optional Additional Environment Variables \uf0c1 WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE Use API to set a specific config parameter \uf0c1 The client library allows one to set config parameter using IoTPConfig_setProperty API. #include <iotp_device.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPDevice *device = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_setProperty(config, \"identity.orgId\", \"a52xin\"); IoTPConfig_setProperty(config, \"identity.typeId\", \"rasberry-pi\"); IoTPConfig_setProperty(config, \"identity.deviceId\", \"00ef08c05\"); IoTPConfig_setProperty(config, \"token.deviceId\", \"Ab$76s)asj8_s5\"); IoTPDevice_create(&device, config);","title":"Configuration"},{"location":"device/config/#device-configuration","text":"Device configuration can be broken down into required and optional configuration:","title":"Device Configuration"},{"location":"device/config/#required-configuration","text":"identity.orgId Your organization ID. identity.typeId The type of the device. Think of the device type is analagous to a model number. identity.deviceId A unique ID to identify a device. Think of the device id as analagous to a serial number. auth.token An authentication token to securely connect your device to Watson IoT Platform.","title":"Required Configuration"},{"location":"device/config/#optional-configuration","text":"options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to 8883 . options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when creating a device client handle IoTPDevice expects to be passed as IoTPConfig object. The device client SDK prrovides three APIs to create or update IoTPConfig object: IoTPConfig_create to read config parameters from an YAML file. IoTPConfig_readEnvironment to read config parameters from environment valiarbles. IoTPConfig_setProperty to set a config parameter by passing parameter name and value.","title":"Optional Configuration"},{"location":"device/config/#yaml-file-support","text":"The client library allows one to easily pass in device configuration using a file. #include <iotp_device.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPDevice *device = NULL; IoTPConfig_create(&config, \"device.yaml\"); IoTPDevice_create(&device, config);","title":"YAML File Support"},{"location":"device/config/#minimal-required-configuration-file","text":"identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5","title":"Minimal Required Configuration File"},{"location":"device/config/#complete-configuration-file","text":"This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem","title":"Complete Configuration File"},{"location":"device/config/#environment-variable-support","text":"The client library allows one to easily pass in device configuration from environment variables. #include <iotp_device.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPDevice *device = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_readEnvironment(config); IoTPDevice_create(&device, config);","title":"Environment Variable Support"},{"location":"device/config/#minimal-required-environment-variables","text":"WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN","title":"Minimal Required Environment Variables"},{"location":"device/config/#optional-additional-environment-variables","text":"WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE","title":"Optional Additional Environment Variables"},{"location":"device/config/#use-api-to-set-a-specific-config-parameter","text":"The client library allows one to set config parameter using IoTPConfig_setProperty API. #include <iotp_device.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPDevice *device = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_setProperty(config, \"identity.orgId\", \"a52xin\"); IoTPConfig_setProperty(config, \"identity.typeId\", \"rasberry-pi\"); IoTPConfig_setProperty(config, \"identity.deviceId\", \"00ef08c05\"); IoTPConfig_setProperty(config, \"token.deviceId\", \"Ab$76s)asj8_s5\"); IoTPDevice_create(&device, config);","title":"Use API to set a specific config parameter"},{"location":"gateway/","text":"Gateway SDK \uf0c1 The gateway SDK includes a shared library that exposes functions to build gateway client that runs on IoT gateways. libwiotp-sdk-gateway-as.so Support APIs for creating a gateway client and managing connection to the Watson IoT Platform service: IoTPConfig_create() IoTPGateway_create() IoTPGateway_connect() Support APIs for working with events and commands: IoTPGateway_sendEvent() IoTPGateway_setEventCallback() IoTPGateway_setCommandsHandler() IoTPGateway_subscribeToCommands() IoTPGateway_sendDeviceEvent() IoTPGateway_subscribeToDeviceCommands() Configuration \uf0c1 Gateway configuration is passed to the client via the IoTPConfig object when you create the client instance or handle IoTPGateway . See the configure gateways section for full details of all available options to configure a client instance. The config handle IoTPConfig created using IoTPConfig_create() must be cleared using IoTPConfig_clear() to avoid handle leak. The gateway handle IoTPGateway created using IoTPGateway_create() must be destroyed using IoTPGateway_destory() to avoid handle leak. Connectivity \uf0c1 IoTPGateway_connect() & IoTPGateway_disconnect() APIs are used to manage the MQTT connection to the Watson IoT Platform service that allows the gateway to handle commands and publish events. Tip Though there are no restrictions on how many gateway clients, a gateway application can create, it is a good practice to not to create many client handles and connect to the Watson IoT platform service, to limit the number of connections to the Watson IoT Platforrm service, and reduce load on the Watson IoT Platform service. Publishing Events \uf0c1 Gateway can provide various types of information, for example data collected by the gateway (telemetry data), current status of the gateway etc. Events are the mechanism by which gateways publish data to the Watson IoT Platform service. The gateway controls the content of the event and assigns a name for each event that it sends. When an event is received by Watson IoT Platform service, the credentials of the received event identify the sending gateway, which means that a gateway cannot impersonate another gateway. Events can be published with any of the three quality of service (QoS) levels that are defined by the MQTT protocol. By default, events are published with a QoS level of 0. Optionally you can send MQTT V5 properties. For details on MQTT V5 properties, refer to MQTTProperty . To send events, you can use IoTPGateway_sendEvent() API. This API takes upto 6 arguments: gateway Client handle event Name of this event msgFormat Format of the data for this event data Data for this event qos MQTT quality of service level to use ( 0 , 1 , or 2 ) props MQTT V5 properties You can set a callback to get send event response using IoTPGateway_setEventCallback() API. The callback returns success and failure responses. The success respose has different implications depending on the level of qos used to publish the event: qos 0: the client has asynchronously begun to send the event qos 1 and 2: the client has confirmation of delivery from the platform Handling Commands \uf0c1 A gateway client can susbcribe to a command using IoTPGateway_subscribeToCommands() API. To process specific commands, you need to register a command callback method, using IoTPGateway_setCommandHandler() . The messages are returned as an instance of the Command class with the following attributes: type : Client type ID id : Client ID command : Identifies the command format : Format that the command was encoded in, for example json payload : Data for the payload payloadlen : Size of the payload buffer Auto-regiter Devices \uf0c1 Gatway devices can automatically register devices that are connected to them. When a gateway publishes a message or subscribes to a topic on behalf of an unregistered device, that device is automatically registered. Tip Registration requests from gateway devices are throttled to 128 pending requests at a time. Attempting to connect many new devices might cause a delay in the registration of the devices through the gateway. Warning If the gateway fails to register a device automatically, it does not attempt to register that device again for a short time. Any messages or subscriptions from the failed device are dropped during that time. Publish Device Event Through Gateway \uf0c1 To send device events, you can use IoTPGateway_sendDeviceEvent() API. This API takes upto 8 arguments: gateway Client handle typeId Device type Id deviceId Device Id event Name of this event msgFormat Format of the data for this event data Data for this event qos MQTT quality of service level to use ( 0 , 1 , or 2 ) props MQTT V5 properties Handling Device Commands \uf0c1 A gateway client can susbcribe to device command connecting thrpugh the gateway client using IoTPGateway_subscribeToDeviceCommands() API. This API takes 5 arguments: gateway Client handle typeId Device type Id deviceId Device Id event Name of this event msgFormat Format of the data for this event To process specific commands, you need to register a command callback method, using IoTPGateway_setCommandHandler() . The messages are returned as an instance of the Command class with the following attributes: type : Client type ID id : Client ID command : Identifies the command format : Format that the command was encoded in, for example json payload : Data for the payload payloadlen : Size of the payload buffer Sample \uf0c1 Sample configuration file \uf0c1 identity: orgId: org1id typeId: testGatewayType gatewayId: testGateway auth: token: testPassword Sample code \uf0c1 #include <iotp_gateway.h> /* Gateway command callback function. Gateway developers can customize this function for their use case. */ void gatewayCommandCallback (char* type, char* id, char* commandName, char *format, void* payload, size_t payloadSize) { fprintf(stdout, \"Received gateway command. Type=%s ID=%s CommandName=%s Format=%s Len=%d\\n\", type?type:\"\", id?id:\"\", commandName?commandName:\"\", format?format:\"\", (int)payloadSize); /* Gateway developers - add your custom code to process gateway command and its payload */ } /* Gateway event callback function. */ void eventCallback(char *id, int rc, void *success void *failure) { fprintf(\"Event callback response for client: %s\\n\", id?id:\"\"); if ( rc == IOTPRC_SUCCESS ) { MQTTAsync_successData5 *response = success; if ( response ) { fprintf(\"Success response code:%d response_message:%s\\n\", response->code, response->message); } else { fprintf(\"Event is published.\\n\"); } } else { MQTTAsync_failureData5 *response = failure; if ( response ) { fprintf(\"Failure response code:%d response_message:%s\\n\", response->code, response->message); } else { fprintf(\"Failed to publish event.\\n\"); } } } int main(int argc, char *argv[]) { int rc = IOTPRC_SUCCESS; IoTPConfig *config = NULL; IoTPGateway *gateway = NULL; /*******************************************************/ /****** Create gateway client instance and connect ******/ /*******************************************************/ /* Create IoTPConfig object, use it to create IoTPGateway handle, and connect client */ rc = IoTPConfig_create(&config, \"configFile.yaml\"); if ( rc == IOTPRC_SUCCESS ) { rc = IoTPGateway_create(&gateway, config); if ( rc == IOTPRC_SUCCESS ) { rc = IoTPGateway_connect(gateway); } } if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to create gateway client: rc=%d reason=%s\\n\", rc, IOTPRC_toString(rc)); exit(1); } /******************************/ /****** Process commands ******/ /******************************/ /* Set gateway command callback for all commands and subscribe to all commands in any supported format */ rc = IoTPGateway_setCommandsHandler(gateway, gatewayCommandCallback); if ( rc == IOTPRC_SUCCESS ) rc = IoTPGateway_subscribeToCommands(gateway, \"+\", \"+\"); } if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to set command handler or subscribe to commands. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /****************************/ /****** Publish events ******/ /****************************/ /* Set event callback to process event response and send event */ rc = IoTPGateway_setEventCallback(gateway, eventCallback); if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to set event callback. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /* Set MQTT V5 properties */ MQTTProperties *properties = (MQTTProperties *)malloc(sizeof MQTTProperties); MQTTProperty property; property.identifier = MQTTPROPERTY_CODE_USER_PROPERTY; property.value.data.data = \"user defined property\"; property.value.data.len = (int)strlen(property.value.data.data); property.value.value.data = \"user defined property value\"; property.value.value.len = (int)strlen(property.value.value.data); rc = MQTTProperties_add(properties, &property); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to set MQTT V5 properties. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /* Set event data */ char *data = \"{\\\"d\\\" : {\\\"SensorID\\\": \\\"Test\\\", \\\"Reading\\\": 7 }}\"; rc = IoTPGateway_sendEvent(gateway,\"status\", data, \"json\", QoS0, properties); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to publish event. rc=%d\\n\", rc); } else { /* wait for sometime to publish data */ sleep(5); } /***********************************/ /****** Publish device events ******/ /***********************************/ /* Set device event data */ char *devdata = \"{\\\"d\\\" : {\\\"TempID\\\": \\\"Test\\\", \\\"Reading\\\": 7 }}\"; rc = IoTPGateway_sendDeviceEvent(gateway, \"testDeviceType\", \"testDevice\", \"deviceStatus\", data, \"json\", QoS0, NULL); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to publish device event. rc=%d\\n\", rc); } else { /* wait for sometime to publish data */ sleep(5); } /*********************/ /****** Cleanup ******/ /*********************/ /* Disconnect, and cleaup */ rc = IoTPGateway_disconnect(gateway); if ( rc == IOTPRC_SUCCESS ) { /* Destroy client */ rc = IoTPGateway_destroy(gateway); if ( rc == IOTPRC_SUCCESS ) { /* Clear configuration */ rc = IoTPConfig_clear(config); } } if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to disconnect or clean handles. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } return rc; } Gateway SDK Reference \uf0c1 For gateway configuration APIs, refer to Configuration Refernce Documentation For gateway client APIs, refer to Gateway Client Refernce Documentation For Return and error codes by C Client SDK, refer to Return Code Refernce Documentation","title":"Gateway SDK"},{"location":"gateway/#gateway-sdk","text":"The gateway SDK includes a shared library that exposes functions to build gateway client that runs on IoT gateways. libwiotp-sdk-gateway-as.so Support APIs for creating a gateway client and managing connection to the Watson IoT Platform service: IoTPConfig_create() IoTPGateway_create() IoTPGateway_connect() Support APIs for working with events and commands: IoTPGateway_sendEvent() IoTPGateway_setEventCallback() IoTPGateway_setCommandsHandler() IoTPGateway_subscribeToCommands() IoTPGateway_sendDeviceEvent() IoTPGateway_subscribeToDeviceCommands()","title":"Gateway SDK"},{"location":"gateway/#configuration","text":"Gateway configuration is passed to the client via the IoTPConfig object when you create the client instance or handle IoTPGateway . See the configure gateways section for full details of all available options to configure a client instance. The config handle IoTPConfig created using IoTPConfig_create() must be cleared using IoTPConfig_clear() to avoid handle leak. The gateway handle IoTPGateway created using IoTPGateway_create() must be destroyed using IoTPGateway_destory() to avoid handle leak.","title":"Configuration"},{"location":"gateway/#connectivity","text":"IoTPGateway_connect() & IoTPGateway_disconnect() APIs are used to manage the MQTT connection to the Watson IoT Platform service that allows the gateway to handle commands and publish events. Tip Though there are no restrictions on how many gateway clients, a gateway application can create, it is a good practice to not to create many client handles and connect to the Watson IoT platform service, to limit the number of connections to the Watson IoT Platforrm service, and reduce load on the Watson IoT Platform service.","title":"Connectivity"},{"location":"gateway/#publishing-events","text":"Gateway can provide various types of information, for example data collected by the gateway (telemetry data), current status of the gateway etc. Events are the mechanism by which gateways publish data to the Watson IoT Platform service. The gateway controls the content of the event and assigns a name for each event that it sends. When an event is received by Watson IoT Platform service, the credentials of the received event identify the sending gateway, which means that a gateway cannot impersonate another gateway. Events can be published with any of the three quality of service (QoS) levels that are defined by the MQTT protocol. By default, events are published with a QoS level of 0. Optionally you can send MQTT V5 properties. For details on MQTT V5 properties, refer to MQTTProperty . To send events, you can use IoTPGateway_sendEvent() API. This API takes upto 6 arguments: gateway Client handle event Name of this event msgFormat Format of the data for this event data Data for this event qos MQTT quality of service level to use ( 0 , 1 , or 2 ) props MQTT V5 properties You can set a callback to get send event response using IoTPGateway_setEventCallback() API. The callback returns success and failure responses. The success respose has different implications depending on the level of qos used to publish the event: qos 0: the client has asynchronously begun to send the event qos 1 and 2: the client has confirmation of delivery from the platform","title":"Publishing Events"},{"location":"gateway/#handling-commands","text":"A gateway client can susbcribe to a command using IoTPGateway_subscribeToCommands() API. To process specific commands, you need to register a command callback method, using IoTPGateway_setCommandHandler() . The messages are returned as an instance of the Command class with the following attributes: type : Client type ID id : Client ID command : Identifies the command format : Format that the command was encoded in, for example json payload : Data for the payload payloadlen : Size of the payload buffer","title":"Handling Commands"},{"location":"gateway/#auto-regiter-devices","text":"Gatway devices can automatically register devices that are connected to them. When a gateway publishes a message or subscribes to a topic on behalf of an unregistered device, that device is automatically registered. Tip Registration requests from gateway devices are throttled to 128 pending requests at a time. Attempting to connect many new devices might cause a delay in the registration of the devices through the gateway. Warning If the gateway fails to register a device automatically, it does not attempt to register that device again for a short time. Any messages or subscriptions from the failed device are dropped during that time.","title":"Auto-regiter Devices"},{"location":"gateway/#publish-device-event-through-gateway","text":"To send device events, you can use IoTPGateway_sendDeviceEvent() API. This API takes upto 8 arguments: gateway Client handle typeId Device type Id deviceId Device Id event Name of this event msgFormat Format of the data for this event data Data for this event qos MQTT quality of service level to use ( 0 , 1 , or 2 ) props MQTT V5 properties","title":"Publish Device Event Through Gateway"},{"location":"gateway/#handling-device-commands","text":"A gateway client can susbcribe to device command connecting thrpugh the gateway client using IoTPGateway_subscribeToDeviceCommands() API. This API takes 5 arguments: gateway Client handle typeId Device type Id deviceId Device Id event Name of this event msgFormat Format of the data for this event To process specific commands, you need to register a command callback method, using IoTPGateway_setCommandHandler() . The messages are returned as an instance of the Command class with the following attributes: type : Client type ID id : Client ID command : Identifies the command format : Format that the command was encoded in, for example json payload : Data for the payload payloadlen : Size of the payload buffer","title":"Handling Device Commands"},{"location":"gateway/#sample","text":"","title":"Sample"},{"location":"gateway/#sample-configuration-file","text":"identity: orgId: org1id typeId: testGatewayType gatewayId: testGateway auth: token: testPassword","title":"Sample configuration file"},{"location":"gateway/#sample-code","text":"#include <iotp_gateway.h> /* Gateway command callback function. Gateway developers can customize this function for their use case. */ void gatewayCommandCallback (char* type, char* id, char* commandName, char *format, void* payload, size_t payloadSize) { fprintf(stdout, \"Received gateway command. Type=%s ID=%s CommandName=%s Format=%s Len=%d\\n\", type?type:\"\", id?id:\"\", commandName?commandName:\"\", format?format:\"\", (int)payloadSize); /* Gateway developers - add your custom code to process gateway command and its payload */ } /* Gateway event callback function. */ void eventCallback(char *id, int rc, void *success void *failure) { fprintf(\"Event callback response for client: %s\\n\", id?id:\"\"); if ( rc == IOTPRC_SUCCESS ) { MQTTAsync_successData5 *response = success; if ( response ) { fprintf(\"Success response code:%d response_message:%s\\n\", response->code, response->message); } else { fprintf(\"Event is published.\\n\"); } } else { MQTTAsync_failureData5 *response = failure; if ( response ) { fprintf(\"Failure response code:%d response_message:%s\\n\", response->code, response->message); } else { fprintf(\"Failed to publish event.\\n\"); } } } int main(int argc, char *argv[]) { int rc = IOTPRC_SUCCESS; IoTPConfig *config = NULL; IoTPGateway *gateway = NULL; /*******************************************************/ /****** Create gateway client instance and connect ******/ /*******************************************************/ /* Create IoTPConfig object, use it to create IoTPGateway handle, and connect client */ rc = IoTPConfig_create(&config, \"configFile.yaml\"); if ( rc == IOTPRC_SUCCESS ) { rc = IoTPGateway_create(&gateway, config); if ( rc == IOTPRC_SUCCESS ) { rc = IoTPGateway_connect(gateway); } } if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to create gateway client: rc=%d reason=%s\\n\", rc, IOTPRC_toString(rc)); exit(1); } /******************************/ /****** Process commands ******/ /******************************/ /* Set gateway command callback for all commands and subscribe to all commands in any supported format */ rc = IoTPGateway_setCommandsHandler(gateway, gatewayCommandCallback); if ( rc == IOTPRC_SUCCESS ) rc = IoTPGateway_subscribeToCommands(gateway, \"+\", \"+\"); } if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to set command handler or subscribe to commands. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /****************************/ /****** Publish events ******/ /****************************/ /* Set event callback to process event response and send event */ rc = IoTPGateway_setEventCallback(gateway, eventCallback); if ( rc != IOTPRC_SUCCESS ) { fprintf(stderr, \"Failed to set event callback. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /* Set MQTT V5 properties */ MQTTProperties *properties = (MQTTProperties *)malloc(sizeof MQTTProperties); MQTTProperty property; property.identifier = MQTTPROPERTY_CODE_USER_PROPERTY; property.value.data.data = \"user defined property\"; property.value.data.len = (int)strlen(property.value.data.data); property.value.value.data = \"user defined property value\"; property.value.value.len = (int)strlen(property.value.value.data); rc = MQTTProperties_add(properties, &property); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to set MQTT V5 properties. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } /* Set event data */ char *data = \"{\\\"d\\\" : {\\\"SensorID\\\": \\\"Test\\\", \\\"Reading\\\": 7 }}\"; rc = IoTPGateway_sendEvent(gateway,\"status\", data, \"json\", QoS0, properties); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to publish event. rc=%d\\n\", rc); } else { /* wait for sometime to publish data */ sleep(5); } /***********************************/ /****** Publish device events ******/ /***********************************/ /* Set device event data */ char *devdata = \"{\\\"d\\\" : {\\\"TempID\\\": \\\"Test\\\", \\\"Reading\\\": 7 }}\"; rc = IoTPGateway_sendDeviceEvent(gateway, \"testDeviceType\", \"testDevice\", \"deviceStatus\", data, \"json\", QoS0, NULL); if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to publish device event. rc=%d\\n\", rc); } else { /* wait for sometime to publish data */ sleep(5); } /*********************/ /****** Cleanup ******/ /*********************/ /* Disconnect, and cleaup */ rc = IoTPGateway_disconnect(gateway); if ( rc == IOTPRC_SUCCESS ) { /* Destroy client */ rc = IoTPGateway_destroy(gateway); if ( rc == IOTPRC_SUCCESS ) { /* Clear configuration */ rc = IoTPConfig_clear(config); } } if ( rc != IOTPRC_SUCCESS ) { fprintf(\"Failed to disconnect or clean handles. rc=%d reason:%s\\n\", rc, IOTPRC_toString(rc)); } return rc; }","title":"Sample code"},{"location":"gateway/#gateway-sdk-reference","text":"For gateway configuration APIs, refer to Configuration Refernce Documentation For gateway client APIs, refer to Gateway Client Refernce Documentation For Return and error codes by C Client SDK, refer to Return Code Refernce Documentation","title":"Gateway SDK Reference"},{"location":"gateway/config/","text":"Gateway Configuration \uf0c1 Gateway configuration can be broken down into required and optional configuration: Required Configuration \uf0c1 identity.orgId Your organization ID. identity.typeId The type of the gateway device. Think of the gateway type is analagous to a model number. identity.deviceId A unique ID to identify a gateway device. Think of the gateway id as analagous to a serial number. auth.token An authentication token to securely connect your gateway device to Watson IoT Platform. Optional Configuration \uf0c1 options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to 8883 . options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when creating a gateway client handle IoTPGateway expects to be passed as IoTPConfig object. The gateway client SDK prrovides three APIs to create or update IoTPConfig object: IoTPConfig_create to read config parameters from an YAML file. IoTPConfig_readEnvironment to read config parameters from environment valiarbles. IoTPConfig_setProperty to set a config parameter by passing parameter name and value. YAML File Support \uf0c1 The client library allows one to easily pass in gateway device configuration using a file. #include <iotp_gateway.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPGateway *gateway = NULL; IoTPConfig_create(&config, \"gateway.yaml\"); IoTPGateway_create(&gateway, config); Minimal Required Configuration File \uf0c1 identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 Complete Configuration File \uf0c1 This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem Environment Variable Support \uf0c1 The client library allows one to easily pass in device configuration from environment variables. #include <iotp_gateway.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPGateway *gateway = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_readEnvironment(config); IoTPGateway_create(&gateway, config); Minimal Required Environment Variables \uf0c1 WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN Optional Additional Environment Variables \uf0c1 WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE Use API to set a specific config parameter \uf0c1 The client library allows one to set config parameter using IoTPConfig_setProperty API. #include <iotp_gateway.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPGateway *gateway = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_setProperty(config, \"identity.orgId\", \"a52xin\"); IoTPConfig_setProperty(config, \"identity.typeId\", \"rasberry-pi\"); IoTPConfig_setProperty(config, \"identity.deviceId\", \"00ef08c05\"); IoTPConfig_setProperty(config, \"token.deviceId\", \"Ab$76s)asj8_s5\"); IoTPGateway_create(&gateway, config);","title":"Configuration"},{"location":"gateway/config/#gateway-configuration","text":"Gateway configuration can be broken down into required and optional configuration:","title":"Gateway Configuration"},{"location":"gateway/config/#required-configuration","text":"identity.orgId Your organization ID. identity.typeId The type of the gateway device. Think of the gateway type is analagous to a model number. identity.deviceId A unique ID to identify a gateway device. Think of the gateway id as analagous to a serial number. auth.token An authentication token to securely connect your gateway device to Watson IoT Platform.","title":"Required Configuration"},{"location":"gateway/config/#optional-configuration","text":"options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to 8883 . options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when creating a gateway client handle IoTPGateway expects to be passed as IoTPConfig object. The gateway client SDK prrovides three APIs to create or update IoTPConfig object: IoTPConfig_create to read config parameters from an YAML file. IoTPConfig_readEnvironment to read config parameters from environment valiarbles. IoTPConfig_setProperty to set a config parameter by passing parameter name and value.","title":"Optional Configuration"},{"location":"gateway/config/#yaml-file-support","text":"The client library allows one to easily pass in gateway device configuration using a file. #include <iotp_gateway.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPGateway *gateway = NULL; IoTPConfig_create(&config, \"gateway.yaml\"); IoTPGateway_create(&gateway, config);","title":"YAML File Support"},{"location":"gateway/config/#minimal-required-configuration-file","text":"identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5","title":"Minimal Required Configuration File"},{"location":"gateway/config/#complete-configuration-file","text":"This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem","title":"Complete Configuration File"},{"location":"gateway/config/#environment-variable-support","text":"The client library allows one to easily pass in device configuration from environment variables. #include <iotp_gateway.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPGateway *gateway = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_readEnvironment(config); IoTPGateway_create(&gateway, config);","title":"Environment Variable Support"},{"location":"gateway/config/#minimal-required-environment-variables","text":"WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN","title":"Minimal Required Environment Variables"},{"location":"gateway/config/#optional-additional-environment-variables","text":"WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE","title":"Optional Additional Environment Variables"},{"location":"gateway/config/#use-api-to-set-a-specific-config-parameter","text":"The client library allows one to set config parameter using IoTPConfig_setProperty API. #include <iotp_gateway.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPGateway *gateway = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_setProperty(config, \"identity.orgId\", \"a52xin\"); IoTPConfig_setProperty(config, \"identity.typeId\", \"rasberry-pi\"); IoTPConfig_setProperty(config, \"identity.deviceId\", \"00ef08c05\"); IoTPConfig_setProperty(config, \"token.deviceId\", \"Ab$76s)asj8_s5\"); IoTPGateway_create(&gateway, config);","title":"Use API to set a specific config parameter"},{"location":"managedDevice/","text":"ManagedDevice SDK \uf0c1 Note This page is still under construction The managed device SDK includes a shared library that exposes functions to build device client that runs on IoT devices. libwiotp-sdk-managedDevice-as.so Support APIs for creating a device client and managing connection to the Watson IoT Platform service: IoTPConfig_create() IoTPManagedDevice_create() IoTPManagedDevice_connect() Support APIs for working with events and commands: IoTPManagedDevice_sendEvent() IoTPManagedDevice_setEventCallback() IoTPManagedDevice_setCommandsHandler() IoTPManagedDevice_subscribeToCommands() Configuration \uf0c1 Managed device configuration is passed to the client via the IoTPConfig object when you create the client instance or handle IoTPManagedDevice . See the configure managed device section for full details of all available options to configure a client instance. The config handle IoTPConfig created using IoTPConfig_create() must be cleared using IoTPConfig_clear() to avoid handle leak. The managed device handle IoTPManagedDevice created using IoTPManagedDevice_create() must be destroyed using IoTPManagedDevice_destory() to avoid handle leak.","title":"Managed Device SDK"},{"location":"managedDevice/#manageddevice-sdk","text":"Note This page is still under construction The managed device SDK includes a shared library that exposes functions to build device client that runs on IoT devices. libwiotp-sdk-managedDevice-as.so Support APIs for creating a device client and managing connection to the Watson IoT Platform service: IoTPConfig_create() IoTPManagedDevice_create() IoTPManagedDevice_connect() Support APIs for working with events and commands: IoTPManagedDevice_sendEvent() IoTPManagedDevice_setEventCallback() IoTPManagedDevice_setCommandsHandler() IoTPManagedDevice_subscribeToCommands()","title":"ManagedDevice SDK"},{"location":"managedDevice/#configuration","text":"Managed device configuration is passed to the client via the IoTPConfig object when you create the client instance or handle IoTPManagedDevice . See the configure managed device section for full details of all available options to configure a client instance. The config handle IoTPConfig created using IoTPConfig_create() must be cleared using IoTPConfig_clear() to avoid handle leak. The managed device handle IoTPManagedDevice created using IoTPManagedDevice_create() must be destroyed using IoTPManagedDevice_destory() to avoid handle leak.","title":"Configuration"},{"location":"managedDevice/config/","text":"ManagedDevice Configuration \uf0c1 ManagedDevice configuration can be broken down into required and optional configuration: Required Configuration \uf0c1 identity.orgId Your organization ID. identity.typeId The type of the managedDevice. Think of the managedDevice type is analagous to a model number. identity.managedDeviceId A unique ID to identify a managedDevice. Think of the managedDevice id as analagous to a serial number. auth.token An authentication token to securely connect your managedDevice to Watson IoT Platform. Optional Configuration \uf0c1 options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to 8883 . options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when creating a managedDevice client handle IoTPManagedDevice expects to be passed as IoTPConfig object. The managedDevice client SDK prrovides three APIs to create or update IoTPConfig object: IoTPConfig_create to read config parameters from an YAML file. IoTPConfig_readEnvironment to read config parameters from environment valiarbles. IoTPConfig_setProperty to set a config parameter by passing parameter name and value. YAML File Support \uf0c1 The client library allows one to easily pass in managedDevice configuration using a file. #include <iotp_managedDevice.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPManagedDevice *managedDevice = NULL; IoTPConfig_create(&config, \"managedDevice.yaml\"); IoTPManagedDevice_create(&managedDevice, config); Minimal Required Configuration File \uf0c1 identity: orgId: org1id typeId: raspberry-pi managedDeviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 Complete Configuration File \uf0c1 This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi managedDeviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem Environment Variable Support \uf0c1 The client library allows one to easily pass in managedDevice configuration from environment variables. #include <iotp_managedDevice.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPManagedDevice *managedDevice = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_readEnvironment(config); IoTPManagedDevice_create(&managedDevice, config); Minimal Required Environment Variables \uf0c1 WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN Optional Additional Environment Variables \uf0c1 WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE Use API to set a specific config parameter \uf0c1 The client library allows one to set config parameter using IoTPConfig_setProperty API. #include <iotp_managedDevice.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPManagedDevice *managedDevice = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_setProperty(config, \"identity.orgId\", \"a52xin\"); IoTPConfig_setProperty(config, \"identity.typeId\", \"rasberry-pi\"); IoTPConfig_setProperty(config, \"identity.managedDeviceId\", \"00ef08c05\"); IoTPConfig_setProperty(config, \"token.managedDeviceId\", \"Ab$76s)asj8_s5\"); IoTPManagedDevice_create(&managedDevice, config);","title":"Configuration"},{"location":"managedDevice/config/#manageddevice-configuration","text":"ManagedDevice configuration can be broken down into required and optional configuration:","title":"ManagedDevice Configuration"},{"location":"managedDevice/config/#required-configuration","text":"identity.orgId Your organization ID. identity.typeId The type of the managedDevice. Think of the managedDevice type is analagous to a model number. identity.managedDeviceId A unique ID to identify a managedDevice. Think of the managedDevice id as analagous to a serial number. auth.token An authentication token to securely connect your managedDevice to Watson IoT Platform.","title":"Required Configuration"},{"location":"managedDevice/config/#optional-configuration","text":"options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to 8883 . options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when creating a managedDevice client handle IoTPManagedDevice expects to be passed as IoTPConfig object. The managedDevice client SDK prrovides three APIs to create or update IoTPConfig object: IoTPConfig_create to read config parameters from an YAML file. IoTPConfig_readEnvironment to read config parameters from environment valiarbles. IoTPConfig_setProperty to set a config parameter by passing parameter name and value.","title":"Optional Configuration"},{"location":"managedDevice/config/#yaml-file-support","text":"The client library allows one to easily pass in managedDevice configuration using a file. #include <iotp_managedDevice.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPManagedDevice *managedDevice = NULL; IoTPConfig_create(&config, \"managedDevice.yaml\"); IoTPManagedDevice_create(&managedDevice, config);","title":"YAML File Support"},{"location":"managedDevice/config/#minimal-required-configuration-file","text":"identity: orgId: org1id typeId: raspberry-pi managedDeviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5","title":"Minimal Required Configuration File"},{"location":"managedDevice/config/#complete-configuration-file","text":"This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi managedDeviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem","title":"Complete Configuration File"},{"location":"managedDevice/config/#environment-variable-support","text":"The client library allows one to easily pass in managedDevice configuration from environment variables. #include <iotp_managedDevice.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPManagedDevice *managedDevice = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_readEnvironment(config); IoTPManagedDevice_create(&managedDevice, config);","title":"Environment Variable Support"},{"location":"managedDevice/config/#minimal-required-environment-variables","text":"WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN","title":"Minimal Required Environment Variables"},{"location":"managedDevice/config/#optional-additional-environment-variables","text":"WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE","title":"Optional Additional Environment Variables"},{"location":"managedDevice/config/#use-api-to-set-a-specific-config-parameter","text":"The client library allows one to set config parameter using IoTPConfig_setProperty API. #include <iotp_managedDevice.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPManagedDevice *managedDevice = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_setProperty(config, \"identity.orgId\", \"a52xin\"); IoTPConfig_setProperty(config, \"identity.typeId\", \"rasberry-pi\"); IoTPConfig_setProperty(config, \"identity.managedDeviceId\", \"00ef08c05\"); IoTPConfig_setProperty(config, \"token.managedDeviceId\", \"Ab$76s)asj8_s5\"); IoTPManagedDevice_create(&managedDevice, config);","title":"Use API to set a specific config parameter"},{"location":"managedGateway/","text":"Managed Gateway SDK \uf0c1 Note This page is still under construction The managed gateway SDK includes a shared library that exposes functions to build device client that runs on IoT gateway. libwiotp-sdk-managedGateway-as.so Support APIs for creating a device client and managing connection to the Watson IoT Platform service: IoTPConfig_create() IoTPManagedGateway_create() IoTPManagedGateway_connect() Support APIs for working with events and commands: IoTPManagedGateway_sendEvent() IoTPManagedGateway_setEventCallback() IoTPManagedGateway_setCommandsHandler() IoTPManagedGateway_subscribeToCommands() Configuration \uf0c1 Managed gateway configuration is passed to the client via the IoTPConfig object when you create the client instance or handle IoTPManagedGateway . See the configure managed gateway section for full details of all available options to configure a client instance. The config handle IoTPConfig created using IoTPConfig_create() must be cleared using IoTPConfig_clear() to avoid handle leak. The managed gateway handle IoTPManagedGateway created using IoTPManagedGateway_create() must be destroyed using IoTPManagedGateway_destory() to avoid handle leak.","title":"Managed Gateway SDK"},{"location":"managedGateway/#managed-gateway-sdk","text":"Note This page is still under construction The managed gateway SDK includes a shared library that exposes functions to build device client that runs on IoT gateway. libwiotp-sdk-managedGateway-as.so Support APIs for creating a device client and managing connection to the Watson IoT Platform service: IoTPConfig_create() IoTPManagedGateway_create() IoTPManagedGateway_connect() Support APIs for working with events and commands: IoTPManagedGateway_sendEvent() IoTPManagedGateway_setEventCallback() IoTPManagedGateway_setCommandsHandler() IoTPManagedGateway_subscribeToCommands()","title":"Managed Gateway SDK"},{"location":"managedGateway/#configuration","text":"Managed gateway configuration is passed to the client via the IoTPConfig object when you create the client instance or handle IoTPManagedGateway . See the configure managed gateway section for full details of all available options to configure a client instance. The config handle IoTPConfig created using IoTPConfig_create() must be cleared using IoTPConfig_clear() to avoid handle leak. The managed gateway handle IoTPManagedGateway created using IoTPManagedGateway_create() must be destroyed using IoTPManagedGateway_destory() to avoid handle leak.","title":"Configuration"},{"location":"managedGateway/config/","text":"ManagedGateway Configuration \uf0c1 ManagedGateway configuration can be broken down into required and optional configuration: Required Configuration \uf0c1 identity.orgId Your organization ID. identity.typeId The type of the managedGateway. Think of the managedGateway type is analagous to a model number. identity.managedGatewayId A unique ID to identify a managedGateway. Think of the managedGateway id as analagous to a serial number. auth.token An authentication token to securely connect your managedGateway to Watson IoT Platform. Optional Configuration \uf0c1 options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to 8883 . options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when creating a managedGateway client handle IoTPManagedGateway expects to be passed as IoTPConfig object. The managedGateway client SDK prrovides three APIs to create or update IoTPConfig object: IoTPConfig_create to read config parameters from an YAML file. IoTPConfig_readEnvironment to read config parameters from environment valiarbles. IoTPConfig_setProperty to set a config parameter by passing parameter name and value. YAML File Support \uf0c1 The client library allows one to easily pass in managedGateway configuration using a file. #include <iotp_managedGateway.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPManagedGateway *managedGateway = NULL; IoTPConfig_create(&config, \"managedGateway.yaml\"); IoTPManagedGateway_create(&managedGateway, config); Minimal Required Configuration File \uf0c1 identity: orgId: org1id typeId: raspberry-pi managedGatewayId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 Complete Configuration File \uf0c1 This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi managedGatewayId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem Environment Variable Support \uf0c1 The client library allows one to easily pass in managedGateway configuration from environment variables. #include <iotp_managedGateway.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPManagedGateway *managedGateway = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_readEnvironment(config); IoTPManagedGateway_create(&managedGateway, config); Minimal Required Environment Variables \uf0c1 WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN Optional Additional Environment Variables \uf0c1 WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE Use API to set a specific config parameter \uf0c1 The client library allows one to set config parameter using IoTPConfig_setProperty API. #include <iotp_managedGateway.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPManagedGateway *managedGateway = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_setProperty(config, \"identity.orgId\", \"a52xin\"); IoTPConfig_setProperty(config, \"identity.typeId\", \"rasberry-pi\"); IoTPConfig_setProperty(config, \"identity.managedGatewayId\", \"00ef08c05\"); IoTPConfig_setProperty(config, \"token.managedGatewayId\", \"Ab$76s)asj8_s5\"); IoTPManagedGateway_create(&managedGateway, config);","title":"Configuration"},{"location":"managedGateway/config/#managedgateway-configuration","text":"ManagedGateway configuration can be broken down into required and optional configuration:","title":"ManagedGateway Configuration"},{"location":"managedGateway/config/#required-configuration","text":"identity.orgId Your organization ID. identity.typeId The type of the managedGateway. Think of the managedGateway type is analagous to a model number. identity.managedGatewayId A unique ID to identify a managedGateway. Think of the managedGateway id as analagous to a serial number. auth.token An authentication token to securely connect your managedGateway to Watson IoT Platform.","title":"Required Configuration"},{"location":"managedGateway/config/#optional-configuration","text":"options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to 8883 . options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when creating a managedGateway client handle IoTPManagedGateway expects to be passed as IoTPConfig object. The managedGateway client SDK prrovides three APIs to create or update IoTPConfig object: IoTPConfig_create to read config parameters from an YAML file. IoTPConfig_readEnvironment to read config parameters from environment valiarbles. IoTPConfig_setProperty to set a config parameter by passing parameter name and value.","title":"Optional Configuration"},{"location":"managedGateway/config/#yaml-file-support","text":"The client library allows one to easily pass in managedGateway configuration using a file. #include <iotp_managedGateway.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPManagedGateway *managedGateway = NULL; IoTPConfig_create(&config, \"managedGateway.yaml\"); IoTPManagedGateway_create(&managedGateway, config);","title":"YAML File Support"},{"location":"managedGateway/config/#minimal-required-configuration-file","text":"identity: orgId: org1id typeId: raspberry-pi managedGatewayId: 00ef08ac05 auth: token: Ab$76s)asj8_s5","title":"Minimal Required Configuration File"},{"location":"managedGateway/config/#complete-configuration-file","text":"This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi managedGatewayId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem","title":"Complete Configuration File"},{"location":"managedGateway/config/#environment-variable-support","text":"The client library allows one to easily pass in managedGateway configuration from environment variables. #include <iotp_managedGateway.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPManagedGateway *managedGateway = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_readEnvironment(config); IoTPManagedGateway_create(&managedGateway, config);","title":"Environment Variable Support"},{"location":"managedGateway/config/#minimal-required-environment-variables","text":"WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN","title":"Minimal Required Environment Variables"},{"location":"managedGateway/config/#optional-additional-environment-variables","text":"WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE","title":"Optional Additional Environment Variables"},{"location":"managedGateway/config/#use-api-to-set-a-specific-config-parameter","text":"The client library allows one to set config parameter using IoTPConfig_setProperty API. #include <iotp_managedGateway.h> IOTPRC rc = IOTP_SUCCESS; IoTPConfig *config = NULL; IoTPManagedGateway *managedGateway = NULL; IoTPConfig_create(&config, NULL); IoTPConfig_setProperty(config, \"identity.orgId\", \"a52xin\"); IoTPConfig_setProperty(config, \"identity.typeId\", \"rasberry-pi\"); IoTPConfig_setProperty(config, \"identity.managedGatewayId\", \"00ef08c05\"); IoTPConfig_setProperty(config, \"token.managedGatewayId\", \"Ab$76s)asj8_s5\"); IoTPManagedGateway_create(&managedGateway, config);","title":"Use API to set a specific config parameter"}]}